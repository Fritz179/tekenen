use image::{io::Reader as ImageReader, GenericImageView};

pub fn preload_image(path: &str) -> Preloaded {
    println!("Loading image: {path}");

    println!("cargo:rerun-if-changed={path}");

    let img = ImageReader::open(path).unwrap().decode().unwrap();

    let mut vec = vec![];

    for y in 0..img.height() {
        for x in 0..img.width() {
            let color = img.get_pixel(x, y);
            vec.push(color[0]);
            vec.push(color[1]);
            vec.push(color[2]);
            vec.push(color[3]);
        }
    };

    let width = img.width();
    let height = img.height();

    Preloaded {
        data_type: "tekenen::Tekenen".to_owned(),
        value: format!("tekenen::Tekenen::from_pixels({width}, {height}, vec!{:?})", vec),
        struct_definitions: Vec::new()
    }
}

fn prepare_preloaded(preloaded: Preloaded) -> String {
    let mut data = preloaded.struct_definitions.join("\n");

    data.push_str(&format!("pub fn load_preloaded() -> {} {{
    {}
}}", preloaded.data_type, preloaded.value));

    data
}

pub fn preload(file_name: &str, preloaded: Preloaded) {
    let data = format!("// This file is computer generated by preloader, please do not modify.
    // Please consider modifying the build.rs.\n\n{}", prepare_preloaded(preloaded));

    println!("{file_name}, {data}");
    std::fs::write(file_name, data).unwrap();
}

pub struct Preloaded {
    data_type: String,
    value: String,
    struct_definitions: Vec<String>
}

static mut ID: i32 = 0;

impl Preloaded {
    pub fn new(data_type: &str, value: &str, struct_definitions: Vec<String>) -> Self {
        Self {
            data_type: data_type.to_owned(),
            value: value.to_owned(),
            struct_definitions
        }
    }

    pub fn number() -> i32 {
        unsafe {
            ID += 1;
            ID - 1
        }
    }
}

pub fn preload_object(data: Vec<(&str, Preloaded)>) -> Preloaded {
    let struct_name = format!("Preloaded_{}", Preloaded::number());
    let mut this_struct = format!("pub struct {struct_name} {{\n");
    let mut all_structs = Vec::new();

    let mut value = format!("{struct_name} {{\n");

    for mut field in data {
        let name = field.0;
        let inner_data_type = field.1.data_type;
        let inner_value = field.1.value;


        this_struct.push_str(&format!("    pub {name}: {inner_data_type},\n"));
        value.push_str(&format!("    {name}: {inner_value},\n"));

        all_structs.append(&mut field.1.struct_definitions);
    }

    value.push('}');
    this_struct.push_str("}\n");

    all_structs.push(this_struct);

    Preloaded {
        data_type: struct_name,
        value,
        struct_definitions: all_structs
    }
}

pub fn preload_array(data: Vec<Preloaded>) -> Preloaded {
    let len = data.len();
    assert!(len > 0, "No preloaded data in array");

    let inner_type = data[0].data_type.clone();
    let data_type = format!("[{inner_type}; {len}]");

    let struct_definitions = data[0].struct_definitions.clone();

    let mut value = "[".to_owned();

    for inner in data {
        value.push_str(&inner.value);
        value.push_str(", ")
    }

    value.remove(value.len() - 1);
    value.remove(value.len() - 1);

    value.push(']');

    Preloaded {
        data_type,
        value,
        struct_definitions
    }
}

#[cfg(test)]
mod tests {
    use crate::*;

    fn simple(num: i32) -> Preloaded {
        Preloaded::new("i32", &format!("{num}"), Vec::new())
    }

    #[test]
    fn simple_value() {
        let data = prepare_preloaded(simple(5));

        assert_eq!(data, "pub fn load_preloaded() -> i32 {
    5
}")
    }

    #[test]
    fn array_simple_value() {
        let data = prepare_preloaded(preload_array(vec![simple(5), simple(6)]));

        assert_eq!(data, "pub fn load_preloaded() -> [i32; 2] {
    [5, 6]
}")
    }

    #[test]
    fn object_simple_value() {
        let data = prepare_preloaded(preload_object(vec![
            ("a", simple(5)),
            ("b", simple(6)),
        ]));

        assert_eq!(data, "pub struct Preloaded_0 {
    pub a: i32,
    pub b: i32,
}
pub fn load_preloaded() -> Preloaded_0 {
    Preloaded_0 {
    a: 5,
    b: 6,
}
}")
    }
}